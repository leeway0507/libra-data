// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAllBooksRowForTest = `-- name: DeleteAllBooksRowForTest :one
DELETE FROM Books RETURNING ID
`

func (q *Queries) DeleteAllBooksRowForTest(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, deleteAllBooksRowForTest)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAllLibariesForTest = `-- name: DeleteAllLibariesForTest :one
DELETE FROM Libraries RETURNING ID
`

func (q *Queries) DeleteAllLibariesForTest(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, deleteAllLibariesForTest)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAllLibsBooksForTest = `-- name: DeleteAllLibsBooksForTest :one
DELETE FROM libsbooks RETURNING ID
`

func (q *Queries) DeleteAllLibsBooksForTest(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, deleteAllLibsBooksForTest)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getBooks = `-- name: GetBooks :many
SELECT id, isbn, title, author, publisher, publicationyear, setisbn, volume, imageurl, description, recommendation, toc, source, url FROM Books
`

func (q *Queries) GetBooks(ctx context.Context) ([]Book, error) {
	rows, err := q.db.Query(ctx, getBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Isbn,
			&i.Title,
			&i.Author,
			&i.Publisher,
			&i.Publicationyear,
			&i.Setisbn,
			&i.Volume,
			&i.Imageurl,
			&i.Description,
			&i.Recommendation,
			&i.Toc,
			&i.Source,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBooksFromIsbn = `-- name: GetBooksFromIsbn :one
SELECT id, isbn, title, author, publisher, publicationyear, setisbn, volume, imageurl, description, recommendation, toc, source, url FROM Books WHERE isbn = $1
`

func (q *Queries) GetBooksFromIsbn(ctx context.Context, isbn pgtype.Text) (Book, error) {
	row := q.db.QueryRow(ctx, getBooksFromIsbn, isbn)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Isbn,
		&i.Title,
		&i.Author,
		&i.Publisher,
		&i.Publicationyear,
		&i.Setisbn,
		&i.Volume,
		&i.Imageurl,
		&i.Description,
		&i.Recommendation,
		&i.Toc,
		&i.Source,
		&i.Url,
	)
	return i, err
}

const insertBooks = `-- name: InsertBooks :many
INSERT INTO
    Books (
        ISBN,
        Title,
        Author,
        Publisher,
        PublicationYear,
        SetISBN,
        Volume,
        ImageURL,
        Description
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    )
ON CONFLICT (ISBN) DO NOTHING
RETURNING
    ID
`

type InsertBooksParams struct {
	Isbn            pgtype.Text
	Title           pgtype.Text
	Author          pgtype.Text
	Publisher       pgtype.Text
	Publicationyear pgtype.Text
	Setisbn         pgtype.Text
	Volume          pgtype.Text
	Imageurl        pgtype.Text
	Description     pgtype.Text
}

func (q *Queries) InsertBooks(ctx context.Context, arg InsertBooksParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, insertBooks,
		arg.Isbn,
		arg.Title,
		arg.Author,
		arg.Publisher,
		arg.Publicationyear,
		arg.Setisbn,
		arg.Volume,
		arg.Imageurl,
		arg.Description,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertLibrariesParams struct {
	Libcode       pgtype.Int4
	Libname       pgtype.Text
	Libaddress    pgtype.Text
	Tel           pgtype.Text
	Latitude      pgtype.Float8
	Longtitude    pgtype.Float8
	Homepage      pgtype.Text
	Closed        pgtype.Text
	Operatingtime pgtype.Text
	Bookcount     pgtype.Int4
}

const insertLibsBooks = `-- name: InsertLibsBooks :many
INSERT INTO
    Libsbooks (
        libcode,
        isbn,
        classnum,
        bookcode,
        shelfcode,
        shelfname
    )
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (isbn, libcode) DO NOTHING
RETURNING
    ID
`

type InsertLibsBooksParams struct {
	Libcode   pgtype.Int4
	Isbn      pgtype.Text
	Classnum  pgtype.Text
	Bookcode  pgtype.Text
	Shelfcode pgtype.Text
	Shelfname pgtype.Text
}

func (q *Queries) InsertLibsBooks(ctx context.Context, arg InsertLibsBooksParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, insertLibsBooks,
		arg.Libcode,
		arg.Isbn,
		arg.Classnum,
		arg.Bookcode,
		arg.Shelfcode,
		arg.Shelfname,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScrapResult = `-- name: UpdateScrapResult :exec
UPDATE Books
SET
    Description = $1,
    Recommendation = $2,
    Toc = $3,
    Source = $4,
    Url = $5
WHERE
    isbn = $6
`

type UpdateScrapResultParams struct {
	Description    pgtype.Text
	Recommendation pgtype.Text
	Toc            pgtype.Text
	Source         pgtype.Text
	Url            pgtype.Text
	Isbn           pgtype.Text
}

func (q *Queries) UpdateScrapResult(ctx context.Context, arg UpdateScrapResultParams) error {
	_, err := q.db.Exec(ctx, updateScrapResult,
		arg.Description,
		arg.Recommendation,
		arg.Toc,
		arg.Source,
		arg.Url,
		arg.Isbn,
	)
	return err
}
